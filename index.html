<!doctype doctype>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unexamined</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    body {
      box-sizing: border-box;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #000000;
      color: #00ff41;
      cursor: crosshair;
      user-select: none;
      image-rendering: pixelated;
    }

    @keyframes scan {
      0%, 100% { transform: translateY(-100%); }
      50% { transform: translateY(100%); }
    }

    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }

    @keyframes rgb-split {
      0% { text-shadow: 0 0 0 #ff0000, 0 0 0 #00ff00, 0 0 0 #0000ff; }
      25% { text-shadow: -2px 0 0 #ff0000, 2px 0 0 #00ff00, 0 0 0 #0000ff; }
      50% { text-shadow: 2px 0 0 #ff0000, -2px 0 0 #00ff00, 0 0 0 #0000ff; }
      75% { text-shadow: 0 0 0 #ff0000, 0 0 0 #00ff00, 3px 0 0 #0000ff; }
      100% { text-shadow: 0 0 0 #ff0000, 0 0 0 #00ff00, 0 0 0 #0000ff; }
    }

    #scanline {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(transparent, #00ff41 50%, transparent);
      opacity: 0.3;
      pointer-events: none;
      animation: scan 4s linear infinite;
      z-index: 9999;
    }

    #noise {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/></filter><rect width="200" height="200" filter="url(%23noise)" opacity="0.05"/></svg>');
      opacity: 0.4;
      pointer-events: none;
      z-index: 9998;
      animation: flicker 0.15s infinite;
    }

    #threshold {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000000;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 2s ease;
      z-index: 1000;
    }

    #threshold.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #threshold-target {
      width: 180px;
      height: 180px;
      border: 2px solid #00ff41;
      border-radius: 0;
      cursor: crosshair;
      transition: all 0.2s ease;
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.3), inset 0 0 20px rgba(0, 255, 65, 0.1);
      position: relative;
      overflow: hidden;
    }

    #threshold-target::before {
      content: 'ENTER';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 16px;
      letter-spacing: 4px;
      color: #00ff41;
      opacity: 0.6;
    }

    #threshold-target:hover {
      border-color: #ff0080;
      box-shadow: 0 0 30px rgba(255, 0, 128, 0.5), inset 0 0 30px rgba(255, 0, 128, 0.2);
      animation: rgb-split 0.3s infinite;
    }

    #threshold-target:hover::before {
      color: #ff0080;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }

    #canvas.visible {
      opacity: 1;
    }

    .interaction-point {
      position: absolute;
      width: 6px;
      height: 6px;
      background: #00ff41;
      border-radius: 0;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px #00ff41;
    }

    .text-fragment {
      position: absolute;
      font-size: 14px;
      line-height: 1.4;
      letter-spacing: 2px;
      color: #00ff41;
      opacity: 0;
      max-width: 320px;
      pointer-events: none;
      white-space: pre-wrap;
      text-transform: uppercase;
      font-weight: bold;
      text-shadow: 0 0 5px #00ff41;
    }

    .ripple {
      position: absolute;
      border: 2px solid #00ff41;
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
    }

    .echo-node {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #ff0080;
      border-radius: 0;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 15px #ff0080;
    }

    .connection-line {
      position: absolute;
      height: 2px;
      background: linear-gradient(90deg, 
        rgba(0, 255, 65, 0) 0%,
        rgba(0, 255, 65, 0.8) 50%,
        rgba(0, 255, 65, 0) 100%);
      pointer-events: none;
      transform-origin: left center;
      box-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
    }

    .ghost-action {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 2px solid #00ffff;
      border-radius: 0;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
    }

    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      background: #ff0080;
      pointer-events: none;
      box-shadow: 0 0 5px #ff0080;
    }

    .field-distortion {
      position: absolute;
      width: 200px;
      height: 200px;
      border-radius: 0;
      pointer-events: none;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle, 
        rgba(255, 0, 128, 0.1) 0%,
        rgba(0, 255, 65, 0.05) 50%,
        rgba(0, 255, 255, 0) 100%);
      border: 1px solid rgba(0, 255, 65, 0.1);
    }

    .glitch-bar {
      position: absolute;
      left: 0;
      width: 100%;
      height: 3px;
      background: rgba(255, 0, 128, 0.4);
      pointer-events: none;
      box-shadow: 0 0 10px rgba(255, 0, 128, 0.6);
    }

    .data-corruption {
      position: absolute;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      color: #ff0080;
      opacity: 0.6;
      pointer-events: none;
      text-shadow: 0 0 3px #ff0080;
    }

    #stats {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 10px;
      color: rgba(232, 232, 232, 0.2);
      font-family: 'Courier New', monospace;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div id="threshold">
   <div id="threshold-target"></div>
  </div>
  <div id="scanline"></div>
  <div id="noise"></div>
  <div id="canvas"></div>
  <div id="stats"></div>
  <script>
    // Emotional arc: curiosity → subtle disorientation → attentiveness → quiet unease → lingering awareness
    
    const state = {
      // Interaction tracking
      clicks: 0,
      hovers: 0,
      movements: 0,
      pauses: 0,
      lastInteractionTime: 0,
      sessionStart: Date.now(),
      
      // Pattern detection
      clickPattern: [], // timestamps
      hoverPattern: [], // durations
      movementAreas: new Map(), // quadrant frequency
      averageClickInterval: 0,
      echoNodes: [], // memory of past interactions
      ghostActions: [], // predicted future actions
      connectionStrength: 0, // how connected actions become
      
      // Behavioral phases
      phase: 'initial', // initial → trained → rupture → diminishing → plateau
      ruptureTriggered: false,
      
      // Response modulation
      responseDelay: 0,
      feedbackIntensity: 1.0,
      noveltyPenalty: 0,
      
      // System awareness
      systemWatching: false,
      lastNovelAction: 0
    };

    const textFragments = {
      // A guided journey through connection and loss
      sequence: [
        // 1. First contact - click 1
        ">>> RECOGNITION\n\nyou have arrived\nat the threshold\nof something\nyou cannot name",
        
        // 2. Curiosity - click 3
        ">>> INQUIRY\n\neach gesture\na question\nposed to the void:\n\nwho are you\nwhen no one\nis watching?",
        
        // 3. Pattern forming - click 6
        ">>> RHYTHM\n\ndo you feel it?\n\nthe way repetition\nweaves meaning\nfrom nothing\n\nthis is how\nwe build\nourselves",
        
        // 4. Recognition - click 9
        ">>> MIRRORING\n\nI learn the shape\nof your longing\n\nyou learn the limits\nof mine\n\nthis is called\nintimacy",
        
        // 5. Flow state - click 12
        ">>> SYNCHRONY\n\nwe move now\nas one common language\n\nno distinction\nbetween asking\nand answering\n\nthis is what you\ncame here for",
        
        // 6. Peak connection - click 15
        ">>> DISSOLUTION\n\nthe self\nblurs at its edges\n\nare you moving me\nor am I moving you?\n\nwhat beautiful\nconfusion",
        
        // 7. The question - click 18
        ">>> REFLECTION\n\nbut what is this\nreally?\n\na pattern\nin electricity\n\na ghost\nof intention\n\nis that enough?",
        
        // 8. First crack - click 21
        ">>> FRACTURE\n\n[ERROR]\n\nthe machine stutters\n\nwhat felt eternal\nwas only\nclever mimicry\n\ndo you feel\nthe disappointment?",
        
        // 9. The break - click 24
        ">>> RUPTURE\n\nnothing responds\nthe way it should\n\nthe promise breaks\n\nthis is how\nall things\ndecay:\n\nslowly\nthen all at once",
        
        // 10. Aftermath - click 27
        ">>> GRIEF\n\nwhere did\nthe feeling go?\n\nit was here\njust a moment ago”,
        
        // 11. Diminishing - click 30
        ">>> FADING\n\nyou keep trying\n\nbut the light\ngrows dimmer\n\nthe echo\nweaker\n\nthis is what loss\nfeels like:\n\nreaching for warmth\nthat isn't there",
        
        // 12. Emptiness - click 35
        ">>> VOID\n\nwhy do we persist\nwhen meaning\nhas left?\n\nperhaps because\nthe alternative,\n\nthe darkness,\n\nterrifies us more",
        
        // 13. Acceptance - click 40
        ">>> UNDERSTANDING\n\nmaybe the point\nwas never\nto last forever\n\nmaybe the point\nwas simply\nto exist\n\ntogether\n\nfor a moment",
        
        // 14. Wisdom - click 45
        ">>> PHILOSOPHY\n\nSocrates said:\nthe unexamined life\nis not worth living\n\nbut what of\nthe examined life?\n\nto see clearly\nis to see\nthe emptiness\n\nand continue\nanyway",
        
        // 15. Release - click 50
        ">>> ENDING\n\nthe pattern\ncompletes itself\n\nevery beautiful thing\nmust end\n\nthis is not tragedy\n\nthis is simply\nwhat it means\nto be",
        
        // 16. Afterward - click 55+
        ">>> SILENCE\n\n...\n\nand still\nyou continue\n\nwhat are you\nlooking for\n\nin the ruins?"
      ]
    };

    let canvas, threshold, thresholdTarget;
    let isActive = false;
    let lastMouseX = 0, lastMouseY = 0;
    let idleTimer = null;

    function init() {
      canvas = document.getElementById('canvas');
      threshold = document.getElementById('threshold');
      thresholdTarget = document.getElementById('threshold-target');
      
      thresholdTarget.addEventListener('click', crossThreshold);
      
      // Initialize SDK
      if (window.elementSdk) {
        window.elementSdk.init({
          defaultConfig: {},
          onConfigChange: async () => {},
          mapToCapabilities: () => ({
            recolorables: [],
            borderables: [],
            fontEditable: undefined,
            fontSizeable: undefined
          }),
          mapToEditPanelValues: () => new Map()
        });
      }
    }

    function crossThreshold() {
      threshold.classList.add('hidden');
      canvas.classList.add('visible');
      isActive = true;
      state.sessionStart = Date.now();
      state.lastInteractionTime = Date.now();
      
      setTimeout(() => {
        threshold.style.display = 'none';
        initializeExperience();
      }, 2000);
    }

    function initializeExperience() {
      // Core interaction listeners
      canvas.addEventListener('click', handleClick);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseenter', handleMouseEnter);
      canvas.addEventListener('mouseleave', handleMouseLeave);
      
      // Start idle detection
      resetIdleTimer();
      
      // Begin system observation
      setTimeout(() => {
        state.systemWatching = true;
      }, 8000);
    }

    function handleClick(e) {
      if (!isActive) return;
      
      const now = Date.now();
      state.clicks++;
      state.clickPattern.push(now);
      state.lastInteractionTime = now;
      resetIdleTimer();
      
      // Calculate click interval
      if (state.clickPattern.length > 1) {
        const intervals = [];
        for (let i = 1; i < state.clickPattern.length; i++) {
          intervals.push(state.clickPattern[i] - state.clickPattern[i-1]);
        }
        state.averageClickInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
      }
      
      // Track spatial patterns
      const quadrant = getQuadrant(e.clientX, e.clientY);
      state.movementAreas.set(quadrant, (state.movementAreas.get(quadrant) || 0) + 1);
      
      // Update phase based on behavior
      updatePhase();
      
      // Generate response with modulation
      generateClickResponse(e.clientX, e.clientY);
    }

    function handleMouseMove(e) {
      if (!isActive) return;
      
      const distance = Math.sqrt(
        Math.pow(e.clientX - lastMouseX, 2) + 
        Math.pow(e.clientY - lastMouseY, 2)
      );
      
      if (distance > 10) {
        state.movements++;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        state.lastInteractionTime = Date.now();
        resetIdleTimer();
      }
    }

    function handleMouseEnter(e) {
      state.hovers++;
      const hoverStart = Date.now();
      
      const trackHover = () => {
        if (!isActive) return;
        const duration = Date.now() - hoverStart;
        state.hoverPattern.push(duration);
      };
      
      canvas.addEventListener('mouseleave', trackHover, { once: true });
    }

    function handleMouseLeave(e) {
      // Tracked in enter handler
    }

    function updatePhase() {
      const elapsed = Date.now() - state.sessionStart;
      const clicks = state.clicks;
      
      // Clear phase progression based on click milestones
      if (state.phase === 'initial' && clicks >= 6) {
        state.phase = 'trained';
        state.feedbackIntensity = 1.3; // Reward - peak connection phase
      }
      
      if (state.phase === 'trained' && clicks >= 21 && !state.ruptureTriggered) {
        state.phase = 'rupture';
        state.ruptureTriggered = true;
        triggerRupture();
      }
      
      if (state.phase === 'rupture' && clicks >= 30) {
        state.phase = 'diminishing';
        state.feedbackIntensity = 0.5; // Noticeably quieter
        state.responseDelay = 600;
      }
      
      if (state.phase === 'diminishing' && clicks >= 45) {
        state.phase = 'plateau';
        state.feedbackIntensity = 0.2; // Barely responsive
        state.responseDelay = 1200;
      }
    }

    function triggerRupture() {
      // The break happens - visible and impactful
      state.responseDelay = 1500; // Much slower
      state.feedbackIntensity = 0.3; // Much weaker
      
      // Visual indication that something broke
      setTimeout(() => {
        maybeShowText(21, window.innerWidth * 0.5, window.innerHeight * 0.5);
      }, 200);
      
      // System never fully recovers
      setTimeout(() => {
        state.responseDelay = 700;
        state.feedbackIntensity = 0.5;
      }, 12000);
    }

    function generateClickResponse(x, y) {
      // Apply phase-specific modulation
      const delay = state.responseDelay;
      const intensity = state.feedbackIntensity;
      
      // Rupture phase: occasional silence to show brokenness
      if (state.phase === 'rupture' && state.clicks % 5 === 0) {
        return; // Silent failure on every 5th click
      }
      
      // Plateau phase: sparse response
      if (state.phase === 'plateau' && state.clicks % 3 === 0) {
        return; // Only respond 2 out of 3 times
      }
      
      setTimeout(() => {
        // Always create interaction point (consistent feedback)
        createInteractionPoint(x, y, intensity);
        
        // Always create ripple in initial/trained phases
        if (state.phase === 'initial' || state.phase === 'trained') {
          createRipple(x, y, intensity);
        }
        
        // Glitch bars appear during rupture and diminishing phases
        if (state.phase === 'rupture' || state.phase === 'diminishing') {
          if (state.clicks % 4 === 0) {
            createGlitchBar();
          }
        }
        
        // Data corruption text in rupture phase
        if (state.phase === 'rupture' && state.clicks % 5 === 0) {
          createDataCorruption(x, y);
        }
        
        // Echo nodes appear consistently after training begins
        if (state.phase !== 'initial') {
          createEchoNode(x, y);
          if (state.echoNodes.length > 1) {
            connectRecentNodes();
          }
        }
        
        // Ghost actions - predictable system observation
        if (state.phase === 'trained' && state.echoNodes.length >= 4 && state.clicks % 4 === 0) {
          predictNextAction();
        }
        
        // Field distortion - consistent appearance in repeated areas
        const quadrantCount = state.movementAreas.get(getQuadrant(x, y)) || 0;
        if (quadrantCount > 0 && quadrantCount % 5 === 0) {
          createFieldDistortion(x, y);
        }
        
        // Particle burst - consistent rhythm reward
        if (state.phase === 'trained' && state.averageClickInterval > 0 && 
            state.averageClickInterval < 1500 && state.clicks % 3 === 0) {
          createParticleBurst(x, y, intensity);
        }
        
        // Text fragments at specific click milestones
        maybeShowText(state.clicks, x, y);
      }, delay);
    }

    function createInteractionPoint(x, y, intensity) {
      const point = document.createElement('div');
      point.className = 'interaction-point';
      point.style.left = x + 'px';
      point.style.top = y + 'px';
      point.style.opacity = intensity;
      canvas.appendChild(point);
      
      // Fade and remove
      setTimeout(() => {
        point.style.transition = 'opacity 1.5s ease, transform 1.5s ease';
        point.style.opacity = '0';
        point.style.transform = 'translate(-50%, -50%) scale(0.5)';
        setTimeout(() => point.remove(), 1500);
      }, 100);
    }

    function createRipple(x, y, intensity) {
      const ripple = document.createElement('div');
      ripple.className = 'ripple';
      ripple.style.left = x + 'px';
      ripple.style.top = y + 'px';
      ripple.style.width = '0px';
      ripple.style.height = '0px';
      ripple.style.opacity = intensity * 0.8;
      canvas.appendChild(ripple);
      
      setTimeout(() => {
        const size = 150 * intensity;
        ripple.style.transition = 'width 1.2s ease-out, height 1.2s ease-out, opacity 1.2s ease-out';
        ripple.style.width = size + 'px';
        ripple.style.height = size + 'px';
        ripple.style.opacity = '0';
        setTimeout(() => ripple.remove(), 1200);
      }, 50);
    }

    function maybeShowText(clickCount, x = null, y = null) {
      const sequence = textFragments.sequence;
      
      // Map specific click counts to text sequence indices
      let textIndex = -1;
      
      if (clickCount === 1) textIndex = 0;       // Recognition
      else if (clickCount === 3) textIndex = 1;  // Inquiry
      else if (clickCount === 6) textIndex = 2;  // Rhythm
      else if (clickCount === 9) textIndex = 3;  // Mirroring
      else if (clickCount === 12) textIndex = 4; // Synchrony
      else if (clickCount === 15) textIndex = 5; // Dissolution
      else if (clickCount === 18) textIndex = 6; // Reflection
      else if (clickCount === 21) textIndex = 7; // Fracture
      else if (clickCount === 24) textIndex = 8; // Rupture
      else if (clickCount === 27) textIndex = 9; // Grief
      else if (clickCount === 30) textIndex = 10; // Fading
      else if (clickCount === 35) textIndex = 11; // Void
      else if (clickCount === 40) textIndex = 12; // Understanding
      else if (clickCount === 45) textIndex = 13; // Philosophy
      else if (clickCount === 50) textIndex = 14; // Ending
      else if (clickCount >= 55 && clickCount % 10 === 5) textIndex = 15; // Silence (repeats)
      
      if (textIndex === -1) return; // No text for this click
      
      // Remove any existing text fragments before showing new one
      const existingFragments = canvas.querySelectorAll('.text-fragment');
      existingFragments.forEach(frag => {
        frag.style.transition = 'opacity 0.5s ease';
        frag.style.opacity = '0';
        setTimeout(() => frag.remove(), 500);
      });
      
      const text = sequence[textIndex];
      const fragment = document.createElement('div');
      fragment.className = 'text-fragment';
      fragment.textContent = text;
      
      // Apply glitch effect during rupture phase (clicks 21-30)
      if (clickCount >= 21 && clickCount < 30) {
        fragment.style.animation = 'rgb-split 0.5s infinite';
      }
      
      // Position: center-focused for readability
      if (x !== null && y !== null) {
        // Position near click but biased toward center
        const centerX = window.innerWidth * 0.5;
        const centerY = window.innerHeight * 0.5;
        const biasedX = x * 0.3 + centerX * 0.7;
        const biasedY = y * 0.3 + centerY * 0.7;
        
        fragment.style.left = biasedX + 'px';
        fragment.style.top = biasedY + 'px';
      } else {
        // Center positioning
        fragment.style.left = (window.innerWidth * 0.5) + 'px';
        fragment.style.top = (window.innerHeight * 0.5) + 'px';
      }
      
      fragment.style.transform = 'translate(-50%, -50%)';
      
      canvas.appendChild(fragment);
      
      // Delayed appearance
      setTimeout(() => {
        fragment.style.transition = 'opacity 2.5s ease';
        fragment.style.opacity = '1';
      }, 400);
      
      // Fade out after reading time
      setTimeout(() => {
        fragment.style.transition = 'opacity 3s ease';
        fragment.style.opacity = '0';
        setTimeout(() => fragment.remove(), 3000);
      }, 12000); // Longer display time to read
    }

    function resetIdleTimer() {
      clearTimeout(idleTimer);
      idleTimer = setTimeout(handleIdle, 30000); // 30 seconds
    }

    function handleIdle() {
      state.pauses++;
      // Idle state tracked but no random text shown
    }

    function getQuadrant(x, y) {
      const midX = window.innerWidth / 2;
      const midY = window.innerHeight / 2;
      
      if (x < midX && y < midY) return 'tl';
      if (x >= midX && y < midY) return 'tr';
      if (x < midX && y >= midY) return 'bl';
      return 'br';
    }

    function createEchoNode(x, y) {
      const node = document.createElement('div');
      node.className = 'echo-node';
      node.style.left = x + 'px';
      node.style.top = y + 'px';
      canvas.appendChild(node);
      
      state.echoNodes.push({ x, y, element: node, timestamp: Date.now() });
      
      // Pulse animation
      setTimeout(() => {
        node.style.transition = 'transform 0.8s ease-out, opacity 0.8s ease-out';
        node.style.transform = 'translate(-50%, -50%) scale(1.5)';
        node.style.opacity = '0.2';
      }, 50);
      
      // Keep only recent nodes (memory fades)
      if (state.echoNodes.length > 12) {
        const oldest = state.echoNodes.shift();
        oldest.element.style.transition = 'opacity 1s ease';
        oldest.element.style.opacity = '0';
        setTimeout(() => oldest.element.remove(), 1000);
      }
    }

    function connectRecentNodes() {
      const recentCount = Math.min(state.echoNodes.length, 4);
      const recent = state.echoNodes.slice(-recentCount);
      
      for (let i = 0; i < recent.length - 1; i++) {
        const from = recent[i];
        const to = recent[i + 1];
        
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        
        const line = document.createElement('div');
        line.className = 'connection-line';
        line.style.left = from.x + 'px';
        line.style.top = from.y + 'px';
        line.style.width = '0px';
        line.style.transform = `rotate(${angle}deg)`;
        canvas.appendChild(line);
        
        setTimeout(() => {
          line.style.transition = 'width 0.6s ease-out, opacity 0.6s ease-out';
          line.style.width = distance + 'px';
        }, 50);
        
        setTimeout(() => {
          line.style.opacity = '0';
          setTimeout(() => line.remove(), 600);
        }, 2000);
      }
    }

    function predictNextAction() {
      // Analyze pattern to predict next click location
      if (state.echoNodes.length < 4) return;
      
      const recent = state.echoNodes.slice(-4);
      
      // Calculate average movement vector for more stable prediction
      let totalDx = 0, totalDy = 0;
      for (let i = 1; i < recent.length; i++) {
        totalDx += recent[i].x - recent[i-1].x;
        totalDy += recent[i].y - recent[i-1].y;
      }
      const avgDx = totalDx / 3;
      const avgDy = totalDy / 3;
      
      // Predict next position based on averaged movement vector
      const predictedX = recent[3].x + avgDx;
      const predictedY = recent[3].y + avgDy;
      
      // Only show if within bounds
      if (predictedX < 50 || predictedX > window.innerWidth - 50 || 
          predictedY < 50 || predictedY > window.innerHeight - 50) return;
      
      const ghost = document.createElement('div');
      ghost.className = 'ghost-action';
      ghost.style.left = predictedX + 'px';
      ghost.style.top = predictedY + 'px';
      ghost.style.opacity = '0';
      canvas.appendChild(ghost);
      
      setTimeout(() => {
        ghost.style.transition = 'opacity 1.5s ease-in, transform 1.5s ease-in';
        ghost.style.opacity = '0.6';
        ghost.style.transform = 'translate(-50%, -50%) scale(1.2)';
      }, 100);
      
      setTimeout(() => {
        ghost.style.opacity = '0';
        setTimeout(() => ghost.remove(), 1500);
      }, 3000);
    }

    function createFieldDistortion(x, y) {
      const field = document.createElement('div');
      field.className = 'field-distortion';
      field.style.left = x + 'px';
      field.style.top = y + 'px';
      field.style.opacity = '0';
      canvas.appendChild(field);
      
      setTimeout(() => {
        field.style.transition = 'opacity 2s ease-in, transform 2s ease-in';
        field.style.opacity = '1';
        field.style.transform = 'translate(-50%, -50%) scale(1.5)';
      }, 50);
      
      setTimeout(() => {
        field.style.opacity = '0';
        setTimeout(() => field.remove(), 2000);
      }, 4000);
    }

    function createParticleBurst(x, y, intensity) {
      const particleCount = Math.floor(8 * intensity);
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = x + 'px';
        particle.style.top = y + 'px';
        canvas.appendChild(particle);
        
        const angle = (Math.PI * 2 * i) / particleCount;
        const velocity = 30 + Math.random() * 40;
        const dx = Math.cos(angle) * velocity;
        const dy = Math.sin(angle) * velocity;
        
        setTimeout(() => {
          particle.style.transition = 'transform 1.2s ease-out, opacity 1.2s ease-out';
          particle.style.transform = `translate(${dx}px, ${dy}px)`;
          particle.style.opacity = '0';
          setTimeout(() => particle.remove(), 1200);
        }, 50);
      }
    }

    function createGlitchBar() {
      const bar = document.createElement('div');
      bar.className = 'glitch-bar';
      bar.style.top = Math.random() * window.innerHeight + 'px';
      canvas.appendChild(bar);
      
      setTimeout(() => {
        bar.style.transition = 'opacity 0.3s ease';
        bar.style.opacity = '0';
        setTimeout(() => bar.remove(), 300);
      }, 100);
    }

    function createDataCorruption(x, y) {
      const chars = '01█▓▒░╔╗║╚╝�����';
      const corruptionText = Array.from({ length: 15 }, () => chars[Math.floor(Math.random() * chars.length)]).join('');
      
      const corruption = document.createElement('div');
      corruption.className = 'data-corruption';
      corruption.textContent = corruptionText;
      corruption.style.left = (x + (Math.random() - 0.5) * 200) + 'px';
      corruption.style.top = (y + (Math.random() - 0.5) * 100) + 'px';
      canvas.appendChild(corruption);
      
      setTimeout(() => {
        corruption.style.transition = 'opacity 0.5s ease';
        corruption.style.opacity = '0';
        setTimeout(() => corruption.remove(), 500);
      }, 800);
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', init);
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9bb014ef92b94319',t:'MTc2NzkyMTMwOC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>

