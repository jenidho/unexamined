<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unexamined</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    body {
      box-sizing: border-box;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #000000;
      color: #00ff41;
      cursor: crosshair;
      user-select: none;
      image-rendering: pixelated;
    }

    @keyframes scan {
      0%, 100% { transform: translateY(-100%); }
      50% { transform: translateY(100%); }
    }

    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }

    @keyframes rgb-split {
      0% { text-shadow: 0 0 0 #ff0000, 0 0 0 #00ff00, 0 0 0 #0000ff; }
      10% { text-shadow: -5px 0 0 #ff0000, 5px 0 0 #00ff00, 0 2px 0 #0000ff; }
      20% { text-shadow: 5px 0 0 #ff0000, -5px 0 0 #00ff00, 0 -2px 0 #0000ff; }
      30% { text-shadow: -3px 2px 0 #ff0000, 3px -2px 0 #00ff00, 6px 0 0 #0000ff; }
      40% { text-shadow: 0 0 0 #ff0000, 0 0 0 #00ff00, 0 0 0 #0000ff; }
      50% { text-shadow: 4px 0 0 #ff0000, -4px 0 0 #00ff00, 0 4px 0 #0000ff; }
      60% { text-shadow: -6px 0 0 #ff0000, 6px 0 0 #00ff00, 0 -3px 0 #0000ff; }
      70% { text-shadow: 2px -3px 0 #ff0000, -2px 3px 0 #00ff00, 5px 0 0 #0000ff; }
      80% { text-shadow: -4px 0 0 #ff0000, 4px 0 0 #00ff00, 0 2px 0 #0000ff; }
      90% { text-shadow: 0 0 0 #ff0000, 0 0 0 #00ff00, 0 0 0 #0000ff; }
      100% { text-shadow: 0 0 0 #ff0000, 0 0 0 #00ff00, 0 0 0 #0000ff; }
    }

    @keyframes text-glitch {
      0% { 
        transform: translate(-50%, -50%);
        text-shadow: 0 0 8px #00ff41;
      }
      5% { 
        transform: translate(calc(-50% + 3px), calc(-50% + 2px));
        text-shadow: -3px 0 8px #ff0000, 3px 0 8px #00ff00, 0 0 8px #0000ff;
      }
      10% { 
        transform: translate(-50%, -50%);
        text-shadow: 0 0 8px #00ff41;
      }
      15% { 
        transform: translate(calc(-50% - 2px), calc(-50% + 3px));
        text-shadow: 2px 0 8px #ff0000, -2px 0 8px #00ff00, 0 0 8px #0000ff;
      }
      20% { 
        transform: translate(-50%, -50%);
        text-shadow: 0 0 8px #00ff41;
      }
      100% { 
        transform: translate(-50%, -50%);
        text-shadow: 0 0 8px #00ff41;
      }
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.15; }
    }

    @keyframes glitch-shift {
      0% { transform: translate(0, 0); }
      20% { transform: translate(-2px, 2px); }
      40% { transform: translate(2px, -2px); }
      60% { transform: translate(-1px, -1px); }
      80% { transform: translate(1px, 1px); }
      100% { transform: translate(0, 0); }
    }

    @keyframes entropy-glitch-light {
      0%, 100% { 
        transform: translate(-50%, -50%);
        filter: none;
      }
      20% { 
        transform: translate(calc(-50% + 2px), calc(-50% - 1px));
        filter: hue-rotate(10deg);
      }
      40% { 
        transform: translate(calc(-50% - 1px), calc(-50% + 2px));
        filter: hue-rotate(-10deg);
      }
    }

    @keyframes entropy-glitch-medium {
      0%, 100% { 
        transform: translate(-50%, -50%) skew(0deg);
        filter: none;
        opacity: 1;
      }
      15% { 
        transform: translate(calc(-50% + 4px), calc(-50% - 3px)) skew(2deg);
        filter: hue-rotate(30deg) saturate(1.5);
        opacity: 0.9;
      }
      35% { 
        transform: translate(calc(-50% - 3px), calc(-50% + 4px)) skew(-2deg);
        filter: hue-rotate(-30deg) saturate(0.5);
        opacity: 0.95;
      }
      50% {
        transform: translate(calc(-50% + 2px), -50%) skew(1deg);
        filter: hue-rotate(15deg);
      }
    }

    @keyframes entropy-glitch-heavy {
      0% { 
        transform: translate(-50%, -50%) skew(0deg);
        filter: none;
        opacity: 1;
      }
      8% { 
        transform: translate(calc(-50% + 8px), calc(-50% - 6px)) skew(5deg);
        filter: hue-rotate(90deg) saturate(2) brightness(1.3);
        opacity: 0.7;
      }
      16% { 
        transform: translate(calc(-50% - 7px), calc(-50% + 5px)) skew(-4deg);
        filter: hue-rotate(-60deg) saturate(0.3) brightness(0.8);
        opacity: 0.85;
      }
      24% {
        transform: translate(calc(-50% + 5px), calc(-50% + 7px)) skew(3deg);
        filter: hue-rotate(120deg) invert(0.2);
        opacity: 0.6;
      }
      32% {
        transform: translate(calc(-50% - 6px), calc(-50% - 4px)) skew(-5deg);
        filter: hue-rotate(-90deg) saturate(1.8);
        opacity: 0.9;
      }
      50% {
        transform: translate(-50%, -50%) skew(2deg);
        filter: hue-rotate(45deg);
        opacity: 0.8;
      }
      100% { 
        transform: translate(-50%, -50%) skew(0deg);
        filter: none;
        opacity: 1;
      }
    }

    @keyframes entropy-glitch-chaos {
      0% { 
        transform: translate(-50%, -50%) skew(0deg) scale(1);
        filter: none;
        opacity: 1;
      }
      5% { 
        transform: translate(calc(-50% + 12px), calc(-50% - 10px)) skew(8deg) scale(1.05);
        filter: hue-rotate(180deg) saturate(3) brightness(1.5) contrast(2);
        opacity: 0.5;
      }
      10% { 
        transform: translate(calc(-50% - 10px), calc(-50% + 12px)) skew(-7deg) scale(0.95);
        filter: hue-rotate(-120deg) saturate(0.2) brightness(0.6) invert(0.3);
        opacity: 0.7;
      }
      15% {
        transform: translate(calc(-50% + 9px), calc(-50% + 8px)) skew(6deg) scale(1.03);
        filter: hue-rotate(240deg) saturate(2.5) contrast(1.8);
        opacity: 0.4;
      }
      20% {
        transform: translate(calc(-50% - 11px), calc(-50% - 7px)) skew(-9deg) scale(0.98);
        filter: hue-rotate(-180deg) invert(0.4) brightness(1.2);
        opacity: 0.65;
      }
      25% {
        transform: translate(calc(-50% + 7px), calc(-50% - 9px)) skew(5deg) scale(1.02);
        filter: hue-rotate(90deg) saturate(1.5);
        opacity: 0.55;
      }
      35% {
        transform: translate(calc(-50% - 8px), calc(-50% + 10px)) skew(-6deg) scale(0.97);
        filter: hue-rotate(-60deg) brightness(0.7);
        opacity: 0.75;
      }
      50% {
        transform: translate(-50%, -50%) skew(3deg) scale(1);
        filter: hue-rotate(30deg);
        opacity: 0.6;
      }
      100% { 
        transform: translate(-50%, -50%) skew(0deg) scale(1);
        filter: hue-rotate(0deg);
        opacity: 1;
      }
    }

    #scanline {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(transparent, #00ff41 50%, transparent);
      opacity: 0.3;
      pointer-events: none;
      animation: scan 4s linear infinite;
      z-index: 9999;
    }

    #noise {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/></filter><rect width="200" height="200" filter="url(%23noise)" opacity="0.05"/></svg>');
      opacity: 0.4;
      pointer-events: none;
      z-index: 9998;
      animation: flicker 0.15s infinite;
      transition: opacity 0.5s ease;
    }

    #background-layer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .rain-drop {
      position: absolute;
      pointer-events: none;
      animation: rain-fall linear infinite;
    }

    .rain-drop::before {
      content: '';
      position: absolute;
      width: 2px;
      height: 2px;
      background: #00ff41;
      border-radius: 50%;
      box-shadow: 0 0 3px rgba(0, 255, 65, 0.3);
    }

    .rain-drop::after {
      content: '';
      position: absolute;
      top: 4px;
      width: 1px;
      height: 35px;
      background: linear-gradient(180deg, 
        rgba(0, 255, 65, 0.25) 0%, 
        rgba(0, 255, 65, 0.15) 20%,
        rgba(0, 255, 65, 0.08) 40%,
        rgba(0, 255, 65, 0.04) 60%,
        transparent 100%);
      box-shadow: 0 0 8px rgba(0, 255, 65, 0.15);
    }

    @keyframes rain-fall {
      0% {
        transform: translateY(-20px);
        opacity: 0;
      }
      5% {
        opacity: 0.35;
      }
      95% {
        opacity: 0.35;
      }
      100% {
        transform: translateY(100vh);
        opacity: 0;
      }
    }

    #threshold {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000000;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 2s ease;
      z-index: 1000;
    }

    #threshold.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #threshold-target {
      width: 180px;
      height: 180px;
      border: 2px solid #00ff41;
      border-radius: 0;
      cursor: crosshair;
      transition: all 0.2s ease;
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.3), inset 0 0 20px rgba(0, 255, 65, 0.1);
      position: relative;
      overflow: hidden;
    }

    #threshold-target::before {
      content: 'ENTER';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 16px;
      letter-spacing: 4px;
      color: #00ff41;
      opacity: 0.6;
    }

    #threshold-target:hover {
      border-color: #ff0080;
      box-shadow: 0 0 40px rgba(255, 0, 128, 0.7), inset 0 0 40px rgba(255, 0, 128, 0.3);
      animation: rgb-split 0.3s infinite;
      transform: scale(1.05);
    }

    #threshold-target:hover::before {
      color: #ff0080;
      text-shadow: 0 0 10px #ff0080;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }

    #canvas.visible {
      opacity: 1;
    }

    .interaction-point {
      position: absolute;
      width: 6px;
      height: 6px;
      background: #00ff41;
      border-radius: 0;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px #00ff41;
    }

    .entropy-light {
      animation: entropy-glitch-light 0.8s infinite !important;
    }

    .entropy-medium {
      animation: entropy-glitch-medium 0.6s infinite !important;
    }

    .entropy-heavy {
      animation: entropy-glitch-heavy 0.4s infinite !important;
    }

    .entropy-chaos {
      animation: entropy-glitch-chaos 0.3s infinite !important;
    }

    .text-fragment {
      position: absolute;
      font-size: 18px;
      line-height: 1.6;
      letter-spacing: 2px;
      color: #00ff41;
      opacity: 0;
      max-width: 580px;
      pointer-events: auto;
      white-space: pre-wrap;
      text-transform: uppercase;
      font-weight: bold;
      text-shadow: 0 0 8px #00ff41;
      animation: text-glitch 3s infinite;
      cursor: crosshair;
      transition: color 0.1s ease, text-shadow 0.1s ease;
    }

    .text-fragment:hover {
      color: #ff0080;
      text-shadow: -2px 0 8px #ff0080, 2px 0 8px #00ff41, 0 0 15px #ff0080;
      animation: text-glitch 3s infinite, rgb-split 0.2s infinite;
    }

    .text-fragment.glitch-phase:hover {
      animation: none !important;
      color: #00ff41 !important;
      text-shadow: 0 0 8px #00ff41 !important;
      filter: none !important;
      transform: translate(-50%, -50%) !important;
    }

    .ripple {
      position: absolute;
      border: 2px solid #00ff41;
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
    }

    .echo-node {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #ff0080;
      border-radius: 0;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 15px #ff0080;
    }

    .connection-line {
      position: absolute;
      height: 2px;
      background: linear-gradient(90deg, 
        rgba(0, 255, 65, 0) 0%,
        rgba(0, 255, 65, 0.8) 50%,
        rgba(0, 255, 65, 0) 100%);
      pointer-events: none;
      transform-origin: left center;
      box-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
    }

    .ghost-action {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 2px solid #00ffff;
      border-radius: 0;
      pointer-events: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
    }

    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      background: #ff0080;
      pointer-events: none;
      box-shadow: 0 0 5px #ff0080;
    }

    .field-distortion {
      position: absolute;
      width: 200px;
      height: 200px;
      border-radius: 0;
      pointer-events: none;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle, 
        rgba(255, 0, 128, 0.1) 0%,
        rgba(0, 255, 65, 0.05) 50%,
        rgba(0, 255, 255, 0) 100%);
      border: 1px solid rgba(0, 255, 65, 0.1);
    }

    .glitch-bar {
      position: absolute;
      left: 0;
      width: 100%;
      height: 3px;
      background: rgba(255, 0, 128, 0.4);
      pointer-events: none;
      box-shadow: 0 0 10px rgba(255, 0, 128, 0.6);
    }

    .data-corruption {
      position: absolute;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      color: #ff0080;
      opacity: 0.6;
      pointer-events: none;
      text-shadow: 0 0 3px #ff0080;
    }

    #click-counter {
      position: fixed;
      bottom: 16px;
      right: 16px;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      color: #00ff41;
      opacity: 0.4;
      pointer-events: none;
      z-index: 10000;
      letter-spacing: 1.5px;
      text-shadow: 0 0 3px rgba(0, 255, 65, 0.4);
      transition: opacity 0.3s ease;
    }

    #click-counter:hover {
      opacity: 0.65;
    }

    .navigation-arrows {
      position: fixed;
      bottom: 16px;
      right: 80px;
      display: flex;
      gap: 20px;
      z-index: 10000;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .navigation-arrows.visible {
      opacity: 0.4;
      pointer-events: auto;
    }

    .nav-arrow {
      color: #00ff41;
      cursor: crosshair;
      text-shadow: 0 0 3px rgba(0, 255, 65, 0.4);
      transition: opacity 0.2s ease, text-shadow 0.2s ease;
      letter-spacing: 1.5px;
      user-select: none;
    }

    .nav-arrow:hover {
      opacity: 1;
      text-shadow: 0 0 8px rgba(0, 255, 65, 0.8);
    }

    .nav-arrow.disabled {
      opacity: 0.15;
      cursor: default;
      pointer-events: none;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div id="threshold">
   <div id="threshold-target"></div>
  </div>
  <div id="background-layer"></div>
  <div id="scanline"></div>
  <div id="noise"></div>
  <div id="canvas"></div>
  <div class="navigation-arrows"><span class="nav-arrow" id="prev-arrow">◀</span> <span class="nav-arrow" id="next-arrow">▶</span>
  </div>
  <div id="click-counter">
   0 / ∞
  </div>
  <script>
    const state = {
      clicks: 0,
      hovers: 0,
      movements: 0,
      pauses: 0,
      lastInteractionTime: 0,
      sessionStart: Date.now(),
      clickPattern: [],
      hoverPattern: [],
      movementAreas: new Map(),
      averageClickInterval: 0,
      echoNodes: [],
      ghostActions: [],
      connectionStrength: 0,
      phase: 'initial',
      ruptureTriggered: false,
      responseDelay: 0,
      feedbackIntensity: 1.0,
      noveltyPenalty: 0,
      systemWatching: false,
      lastNovelAction: 0
    };

    const textFragments = {
      sequence: [
        ">> RECOGNITION\n\nYou have arrived at the threshold\nof something you cannot name.",
        ">> INQUIRY\n\nA question emerges in the void.\n\nWho are you when no one is watching?",
        ">> RHYTHM\n\nDo you feel it?\nThe way repetition weaves meaning\nfrom nothing.\n\nThis is how we build ourselves.",
        ">> MIRRORING\n\nI learn the shape of your longing.\nYou learn the limits of mine.\n\nThis is called intimacy.",
        ">> SYNCHRONY\n\nWe move now as one common language.\n\nNo distinction between you and I.\n\nThis is what you came here for.",
        ">> DISSOLUTION\n\nThe self blurs at the edges.\n\nAre you shaping me, or am I shaping you?\n\nWhat beautiful confusion.",
        ">> REFLECTION\n\nBut what is this really?\n\nA chance encounter?\nA pattern in electricity?\n\nIs that enough?",
        ">> FRACTURE\n\n[ERROR]\n\nThe machine stutters.\n\nWhat felt eternal was only clever mimicry.\n\nDo you feel the disappointment?",
        ">> RUPTURE\n\nNothing responds the way it should.\n\nThe promise breaks.\n\nThis is how all things decay:\nslowly, then all at once.",
        ">> GRIEF\n\nWhere did the feeling go?\n\nIt was here just a moment ago.",
        ">> UNDERSTANDING\n\nMaybe the point was never to last forever.\n\nMaybe the point was simply to exist\ntogether, for a moment, and to know that we were there.",
        ">> PHILOSOPHY\n\nSocrates said the unexamined life is not worth living.\n\nBut what of the examined life?\n\nTo see clearly is to watch our pattern complete itself.",
        ">> ENDING\n\nEvery beautiful thing must end.\n\nThis is not tragedy.\nThis is simply what it means to be.",
        ">> EPITAPH\n\n...\n\nOh, you're still here?\n\nWhat are you looking for\nin the ruins?"
      ]
    };

    let canvas, threshold, thresholdTarget, backgroundLayer;
    let isActive = false;
    let lastMouseX = 0, lastMouseY = 0;
    let idleTimer = null;

    function init() {
      canvas = document.getElementById('canvas');
      threshold = document.getElementById('threshold');
      thresholdTarget = document.getElementById('threshold-target');
      backgroundLayer = document.getElementById('background-layer');
      
      thresholdTarget.addEventListener('click', crossThreshold);
      initializeBackgroundPatterns();
      
      if (window.elementSdk) {
        window.elementSdk.init({
          defaultConfig: {},
          onConfigChange: async () => {},
          mapToCapabilities: () => ({
            recolorables: [],
            borderables: [],
            fontEditable: undefined,
            fontSizeable: undefined
          }),
          mapToEditPanelValues: () => new Map()
        });
      }
    }

    function initializeBackgroundPatterns() {
      // Create beautiful raindrop effect
      const rainCount = 35;
      for (let i = 0; i < rainCount; i++) {
        const drop = document.createElement('div');
        drop.className = 'rain-drop';
        drop.style.left = Math.random() * 100 + '%';
        drop.style.animationDuration = (3 + Math.random() * 4) + 's';
        drop.style.animationDelay = Math.random() * 6 + 's';
        backgroundLayer.appendChild(drop);
      }
    }

    function updateBackgroundIntensity() {
      const clicks = state.clicks;
      const noise = document.getElementById('noise');
      
      let noiseOpacity = 0.4;
      
      if (clicks >= 1 && clicks < 8) {
        noiseOpacity = 0.4;
      } else if (clicks >= 8 && clicks < 14) {
        noiseOpacity = 0.5;
      } else if (clicks >= 14 && clicks < 20) {
        noiseOpacity = 0.65;
      } else if (clicks >= 20 && clicks < 29) {
        noiseOpacity = 0.8;
      } else if (clicks >= 29) {
        noiseOpacity = 0.95;
      }
      
      noise.style.opacity = noiseOpacity;
    }

    function updateClickCounter() {
      const counter = document.getElementById('click-counter');
      if (counter) {
        counter.textContent = `${state.clicks} / ∞`;
      }
      
      updateNavigationArrows();
    }

    function updateNavigationArrows() {
      const arrows = document.querySelector('.navigation-arrows');
      const prevArrow = document.getElementById('prev-arrow');
      const nextArrow = document.getElementById('next-arrow');
      
      if (!arrows || !prevArrow || !nextArrow) return;
      
      // Show arrows starting at click 1 (once you enter)
      if (state.clicks >= 1 && state.clicks < 29) {
        arrows.classList.add('visible');
        
        // Update disabled states
        if (state.clicks <= 1) {
          prevArrow.classList.add('disabled');
        } else {
          prevArrow.classList.remove('disabled');
        }
        
        // Can always go forward until we hit the end
        nextArrow.classList.remove('disabled');
      } else {
        arrows.classList.remove('visible');
      }
    }

    function createThematicLayer(textIndex) {
      const layer = document.createElement('div');
      layer.style.position = 'absolute';
      layer.style.top = '0';
      layer.style.left = '0';
      layer.style.width = '100%';
      layer.style.height = '100%';
      layer.style.pointerEvents = 'none';
      layer.style.opacity = '0';
      layer.style.transition = 'opacity 2s ease';
      layer.style.zIndex = '2';
      
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const maxDimension = Math.max(window.innerWidth, window.innerHeight);
      
      // Garden-inspired geometric patterns
      if (textIndex === 0) {
        // RECOGNITION - Seed/bloom - circle filling screen
        const circle = document.createElement('div');
        circle.style.position = 'absolute';
        circle.style.border = '1px solid rgba(0, 255, 65, 0.15)';
        circle.style.borderRadius = '50%';
        circle.style.width = (maxDimension * 0.55) + 'px';
        circle.style.height = (maxDimension * 0.55) + 'px';
        circle.style.left = centerX + 'px';
        circle.style.top = centerY + 'px';
        circle.style.transform = 'translate(-50%, -50%)';
        layer.appendChild(circle);
        
        // Add scattered points like pollen
        for (let i = 0; i < 24; i++) {
          const dot = document.createElement('div');
          dot.style.position = 'absolute';
          dot.style.width = '2px';
          dot.style.height = '2px';
          dot.style.background = 'rgba(0, 255, 65, 0.2)';
          const angle = (i * 15) * Math.PI / 180;
          const radius = maxDimension * 0.18 + Math.random() * (maxDimension * 0.12);
          dot.style.left = (centerX + Math.cos(angle) * radius) + 'px';
          dot.style.top = (centerY + Math.sin(angle) * radius) + 'px';
          layer.appendChild(dot);
        }
      } else if (textIndex === 1) {
        // INQUIRY - Intersecting growth circles like overlapping leaves
        for (let i = 0; i < 2; i++) {
          const circle = document.createElement('div');
          circle.style.position = 'absolute';
          circle.style.border = '1px solid rgba(0, 255, 65, 0.15)';
          circle.style.borderRadius = '50%';
          const size = maxDimension * 0.45;
          circle.style.width = size + 'px';
          circle.style.height = size + 'px';
          circle.style.left = (centerX + (i === 0 ? -maxDimension * 0.09 : maxDimension * 0.09)) + 'px';
          circle.style.top = centerY + 'px';
          circle.style.transform = 'translate(-50%, -50%)';
          layer.appendChild(circle);
        }
        
        // Add stems/veins
        for (let i = 0; i < 12; i++) {
          const stem = document.createElement('div');
          stem.style.position = 'absolute';
          stem.style.width = '1px';
          stem.style.height = (maxDimension * 0.2) + 'px';
          stem.style.background = 'rgba(0, 255, 65, 0.1)';
          stem.style.left = centerX + 'px';
          stem.style.top = (centerY + maxDimension * 0.12) + 'px';
          stem.style.transformOrigin = 'top center';
          stem.style.transform = `rotate(${i * 30 - 180}deg)`;
          layer.appendChild(stem);
        }
      } else if (textIndex === 2) {
        // RHYTHM - Growth rings like tree rings
        for (let i = 0; i < 7; i++) {
          const circle = document.createElement('div');
          circle.style.position = 'absolute';
          circle.style.border = '1px solid rgba(0, 255, 65, ' + (0.2 - i * 0.02) + ')';
          circle.style.borderRadius = '50%';
          const size = maxDimension * 0.3 + i * (maxDimension * 0.12);
          circle.style.width = size + 'px';
          circle.style.height = size + 'px';
          circle.style.left = centerX + 'px';
          circle.style.top = centerY + 'px';
          circle.style.transform = 'translate(-50%, -50%)';
          layer.appendChild(circle);
        }
        
        // Add radial lines like wood grain
        for (let i = 0; i < 16; i++) {
          const line = document.createElement('div');
          line.style.position = 'absolute';
          line.style.width = '1px';
          line.style.height = (maxDimension * 0.55) + 'px';
          line.style.background = 'linear-gradient(180deg, transparent, rgba(0, 255, 65, 0.08), transparent)';
          line.style.left = centerX + 'px';
          line.style.top = centerY + 'px';
          line.style.transformOrigin = 'center';
          line.style.transform = `rotate(${i * 22.5}deg)`;
          layer.appendChild(line);
        }
      } else if (textIndex === 3) {
        // MIRRORING - Flower petals with 8 petals
        for (let i = 0; i < 8; i++) {
          const petal = document.createElement('div');
          petal.style.position = 'absolute';
          petal.style.border = '1px solid rgba(0, 255, 65, 0.15)';
          petal.style.borderRadius = '50%';
          petal.style.width = (maxDimension * 0.2) + 'px';
          petal.style.height = (maxDimension * 0.35) + 'px';
          const angle = (i * 45) * Math.PI / 180;
          const radius = maxDimension * 0.15;
          petal.style.left = (centerX + Math.cos(angle) * radius) + 'px';
          petal.style.top = (centerY + Math.sin(angle) * radius) + 'px';
          petal.style.transform = `translate(-50%, -50%) rotate(${i * 45}deg)`;
          layer.appendChild(petal);
        }
        
        // Center of flower
        const center = document.createElement('div');
        center.style.position = 'absolute';
        center.style.border = '1px solid rgba(0, 255, 65, 0.2)';
        center.style.borderRadius = '50%';
        center.style.width = (maxDimension * 0.1) + 'px';
        center.style.height = (maxDimension * 0.1) + 'px';
        center.style.left = centerX + 'px';
        center.style.top = centerY + 'px';
        center.style.transform = 'translate(-50%, -50%)';
        layer.appendChild(center);
      } else if (textIndex === 4) {
        // SYNCHRONY - Root system spreading
        for (let i = 0; i < 20; i++) {
          const root = document.createElement('div');
          root.style.position = 'absolute';
          root.style.width = '1px';
          root.style.height = '45%';
          root.style.background = 'linear-gradient(180deg, rgba(0, 255, 65, 0.2), transparent)';
          root.style.left = centerX + 'px';
          root.style.top = centerY + 'px';
          root.style.transformOrigin = 'top center';
          root.style.transform = `rotate(${i * 18}deg)`;
          layer.appendChild(root);
        }
        
        // Add nodes along roots like mycorrhizae
        for (let i = 0; i < 40; i++) {
          const node = document.createElement('div');
          node.style.position = 'absolute';
          node.style.width = '3px';
          node.style.height = '3px';
          node.style.background = 'rgba(0, 255, 65, 0.15)';
          node.style.borderRadius = '50%';
          const angle = (i * 9) * Math.PI / 180;
          const radius = maxDimension * 0.15 + Math.random() * (maxDimension * 0.3);
          node.style.left = (centerX + Math.cos(angle) * radius) + 'px';
          node.style.top = (centerY + Math.sin(angle) * radius) + 'px';
          layer.appendChild(node);
        }
      } else if (textIndex === 5) {
        // DISSOLUTION - Wilting flowers/overlapping circles
        for (let i = 0; i < 6; i++) {
          const circle = document.createElement('div');
          circle.style.position = 'absolute';
          circle.style.border = '1px solid rgba(0, 255, 65, 0.1)';
          circle.style.borderRadius = '50%';
          const size = maxDimension * 0.5;
          circle.style.width = size + 'px';
          circle.style.height = size + 'px';
          const angle = (i * 60) * Math.PI / 180;
          const radius = maxDimension * 0.13;
          circle.style.left = (centerX + Math.cos(angle) * radius) + 'px';
          circle.style.top = (centerY + Math.sin(angle) * radius) + 'px';
          circle.style.transform = 'translate(-50%, -50%)';
          layer.appendChild(circle);
        }
        
        // Scattered leaf-like shapes
        for (let i = 0; i < 30; i++) {
          const leaf = document.createElement('div');
          leaf.style.position = 'absolute';
          leaf.style.width = (maxDimension * 0.04) + 'px';
          leaf.style.height = (maxDimension * 0.02) + 'px';
          leaf.style.border = '1px solid rgba(0, 255, 65, 0.08)';
          leaf.style.borderRadius = '50% 0';
          const angle = Math.random() * Math.PI * 2;
          const radius = maxDimension * 0.25 + Math.random() * (maxDimension * 0.25);
          leaf.style.left = (centerX + Math.cos(angle) * radius) + 'px';
          leaf.style.top = (centerY + Math.sin(angle) * radius) + 'px';
          leaf.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg)`;
          layer.appendChild(leaf);
        }
      } else if (textIndex === 6) {
        // REFLECTION - Honeycomb hexagonal structure
        const hexSize = maxDimension * 0.08;
        for (let row = -4; row <= 4; row++) {
          for (let col = -5; col <= 5; col++) {
            const hexagon = document.createElement('div');
            hexagon.style.position = 'absolute';
            hexagon.style.width = hexSize + 'px';
            hexagon.style.height = hexSize + 'px';
            
            const xOffset = col * hexSize * 0.866;
            const yOffset = row * hexSize * 0.75 + (col % 2) * hexSize * 0.375;
            
            hexagon.style.left = (centerX + xOffset) + 'px';
            hexagon.style.top = (centerY + yOffset) + 'px';
            hexagon.style.transform = 'translate(-50%, -50%)';
            
            for (let i = 0; i < 6; i++) {
              const line = document.createElement('div');
              line.style.position = 'absolute';
              line.style.width = hexSize + 'px';
              line.style.height = '1px';
              line.style.background = 'rgba(0, 255, 65, 0.12)';
              line.style.left = '50%';
              line.style.top = '50%';
              line.style.transformOrigin = 'center';
              line.style.transform = `translate(-50%, -50%) rotate(${i * 60}deg)`;
              hexagon.appendChild(line);
            }
            layer.appendChild(hexagon);
          }
        }
      } else if (textIndex === 7) {
        // FRACTURE - Broken circle with gaps
        const segments = 8;
        for (let i = 0; i < segments; i++) {
          if (i % 2 === 0) {
            const arc = document.createElement('div');
            arc.style.position = 'absolute';
            const size = maxDimension * 0.7;
            arc.style.width = size + 'px';
            arc.style.height = size + 'px';
            arc.style.left = centerX + 'px';
            arc.style.top = centerY + 'px';
            arc.style.transform = 'translate(-50%, -50%)';
            arc.style.border = '1px solid rgba(255, 0, 128, 0.2)';
            arc.style.borderRadius = '50%';
            const clipAngle = 45;
            arc.style.clipPath = `polygon(50% 50%, ${50 + 50 * Math.cos(i * 45 * Math.PI / 180)}% ${50 + 50 * Math.sin(i * 45 * Math.PI / 180)}%, ${50 + 50 * Math.cos((i * 45 + clipAngle) * Math.PI / 180)}% ${50 + 50 * Math.sin((i * 45 + clipAngle) * Math.PI / 180)}%)`;
            layer.appendChild(arc);
          }
        }
      } else if (textIndex === 8) {
        // RUPTURE - Shattered cross
        const lineLength = maxDimension * 0.3;
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            const fragment = document.createElement('div');
            fragment.style.position = 'absolute';
            fragment.style.width = (maxDimension * 0.08) + 'px';
            fragment.style.height = '1px';
            fragment.style.background = 'rgba(255, 0, 128, 0.25)';
            const angle = i * 90;
            const distance = maxDimension * 0.08 + j * (maxDimension * 0.08);
            const radians = angle * Math.PI / 180;
            fragment.style.left = (centerX + Math.cos(radians) * distance) + 'px';
            fragment.style.top = (centerY + Math.sin(radians) * distance) + 'px';
            fragment.style.transform = `translate(-50%, -50%) rotate(${angle + (Math.random() * 30 - 15)}deg)`;
            layer.appendChild(fragment);
          }
        }
      } else if (textIndex === 9) {
        // GRIEF - Fading concentric squares
        for (let i = 0; i < 4; i++) {
          const square = document.createElement('div');
          square.style.position = 'absolute';
          square.style.border = '1px solid rgba(255, 0, 128, ' + (0.15 - i * 0.03) + ')';
          const size = maxDimension * 0.4 + i * (maxDimension * 0.15);
          square.style.width = size + 'px';
          square.style.height = size + 'px';
          square.style.left = centerX + 'px';
          square.style.top = centerY + 'px';
          square.style.transform = 'translate(-50%, -50%) rotate(10deg)';
          layer.appendChild(square);
        }
      } else if (textIndex === 10) {
        // UNDERSTANDING - Yin-yang inspired duality
        const size = maxDimension * 0.65;
        const circle1 = document.createElement('div');
        circle1.style.position = 'absolute';
        circle1.style.border = '1px solid rgba(0, 255, 65, 0.15)';
        circle1.style.borderRadius = '50%';
        circle1.style.width = size + 'px';
        circle1.style.height = size + 'px';
        circle1.style.left = centerX + 'px';
        circle1.style.top = centerY + 'px';
        circle1.style.transform = 'translate(-50%, -50%)';
        circle1.style.clipPath = 'polygon(50% 0%, 100% 0%, 100% 100%, 50% 100%)';
        layer.appendChild(circle1);
        
        const circle2 = document.createElement('div');
        circle2.style.position = 'absolute';
        circle2.style.border = '1px solid rgba(0, 255, 65, 0.15)';
        circle2.style.borderRadius = '50%';
        circle2.style.width = size + 'px';
        circle2.style.height = size + 'px';
        circle2.style.left = centerX + 'px';
        circle2.style.top = centerY + 'px';
        circle2.style.transform = 'translate(-50%, -50%)';
        circle2.style.clipPath = 'polygon(0% 0%, 50% 0%, 50% 100%, 0% 100%)';
        layer.appendChild(circle2);
      } else if (textIndex === 11) {
        // PHILOSOPHY - Sacred geometry flower
        const size = maxDimension * 0.35;
        for (let i = 0; i < 6; i++) {
          const circle = document.createElement('div');
          circle.style.position = 'absolute';
          circle.style.border = '1px solid rgba(0, 255, 65, 0.12)';
          circle.style.borderRadius = '50%';
          circle.style.width = size + 'px';
          circle.style.height = size + 'px';
          const angle = (i * 60) * Math.PI / 180;
          const radius = maxDimension * 0.175;
          circle.style.left = (centerX + Math.cos(angle) * radius) + 'px';
          circle.style.top = (centerY + Math.sin(angle) * radius) + 'px';
          circle.style.transform = 'translate(-50%, -50%)';
          layer.appendChild(circle);
        }
      } else if (textIndex === 12) {
        // ENDING - Perfect circle closing
        const circle = document.createElement('div');
        circle.style.position = 'absolute';
        circle.style.border = '2px solid rgba(0, 255, 65, 0.2)';
        circle.style.borderRadius = '50%';
        const size = maxDimension * 0.85;
        circle.style.width = size + 'px';
        circle.style.height = size + 'px';
        circle.style.left = centerX + 'px';
        circle.style.top = centerY + 'px';
        circle.style.transform = 'translate(-50%, -50%)';
        circle.style.boxShadow = '0 0 30px rgba(0, 255, 65, 0.1)';
        layer.appendChild(circle);
      } else if (textIndex === 13) {
        // RUINS - Scattered fragments and broken geometry
        for (let i = 0; i < 25; i++) {
          const fragment = document.createElement('div');
          fragment.style.position = 'absolute';
          fragment.style.border = '1px solid rgba(0, 255, 65, 0.06)';
          const width = (maxDimension * 0.02) + Math.random() * (maxDimension * 0.08);
          const height = (maxDimension * 0.02) + Math.random() * (maxDimension * 0.08);
          fragment.style.width = width + 'px';
          fragment.style.height = height + 'px';
          const angle = Math.random() * Math.PI * 2;
          const radius = maxDimension * 0.15 + Math.random() * (maxDimension * 0.35);
          fragment.style.left = (centerX + Math.cos(angle) * radius) + 'px';
          fragment.style.top = (centerY + Math.sin(angle) * radius) + 'px';
          fragment.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg)`;
          layer.appendChild(fragment);
        }
        
        // Add broken circle arcs
        for (let i = 0; i < 6; i++) {
          const arc = document.createElement('div');
          arc.style.position = 'absolute';
          const size = maxDimension * 0.3 + i * (maxDimension * 0.08);
          arc.style.width = size + 'px';
          arc.style.height = size + 'px';
          arc.style.left = centerX + 'px';
          arc.style.top = centerY + 'px';
          arc.style.transform = 'translate(-50%, -50%)';
          arc.style.border = '1px solid rgba(0, 255, 65, 0.05)';
          arc.style.borderRadius = '50%';
          const startAngle = Math.random() * 360;
          const arcLength = 30 + Math.random() * 60;
          arc.style.clipPath = `polygon(50% 50%, ${50 + 50 * Math.cos(startAngle * Math.PI / 180)}% ${50 + 50 * Math.sin(startAngle * Math.PI / 180)}%, ${50 + 50 * Math.cos((startAngle + arcLength) * Math.PI / 180)}% ${50 + 50 * Math.sin((startAngle + arcLength) * Math.PI / 180)}%)`;
          layer.appendChild(arc);
        }
      }
      
      canvas.appendChild(layer);
      
      setTimeout(() => {
        layer.style.opacity = '0.6';
      }, 100);
      
      return layer;
    }

    function crossThreshold() {
      threshold.classList.add('hidden');
      canvas.classList.add('visible');
      isActive = true;
      state.sessionStart = Date.now();
      state.lastInteractionTime = Date.now();
      
      setTimeout(() => {
        threshold.style.display = 'none';
        initializeExperience();
      }, 2000);
    }

    function initializeExperience() {
      canvas.addEventListener('click', handleClick);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseenter', handleMouseEnter);
      canvas.addEventListener('mouseleave', handleMouseLeave);
      
      // Setup navigation arrows
      const prevArrow = document.getElementById('prev-arrow');
      const nextArrow = document.getElementById('next-arrow');
      
      if (prevArrow) {
        prevArrow.addEventListener('click', (e) => {
          e.stopPropagation();
          navigatePage(-1);
        });
      }
      
      if (nextArrow) {
        nextArrow.addEventListener('click', (e) => {
          e.stopPropagation();
          navigatePage(1);
        });
      }
      
      resetIdleTimer();
      
      setTimeout(() => {
        state.systemWatching = true;
      }, 8000);
    }

    function navigatePage(direction) {
      if (direction > 0) {
        // Move forward - simulate a click
        handleClick({ clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 });
      } else if (direction < 0 && state.clicks > 1) {
        // Move backward
        state.clicks -= 2; // Subtract 2 because handleClick will add 1
        if (state.clicks < 0) state.clicks = 0;
        handleClick({ clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 });
      }
    }

    function handleClick(e) {
      if (!isActive) return;
      
      // Hide navigation arrows during interaction
      const arrows = document.querySelector('.navigation-arrows');
      if (arrows) {
        arrows.classList.remove('visible');
      }
      
      // Check if we're in the pink glitch phase (clicks 14-18)
      if (state.clicks >= 14 && state.clicks < 18) {
        // Freeze everything - stop accepting clicks
        isActive = false;
        canvas.style.pointerEvents = 'none';
        
        // Resume after 2 seconds
        setTimeout(() => {
          isActive = true;
          canvas.style.pointerEvents = 'auto';
        }, 2000);
      }
      
      const now = Date.now();
      state.clicks++;
      state.clickPattern.push(now);
      state.lastInteractionTime = now;
      resetIdleTimer();
      
      if (state.clickPattern.length > 1) {
        const intervals = [];
        for (let i = 1; i < state.clickPattern.length; i++) {
          intervals.push(state.clickPattern[i] - state.clickPattern[i-1]);
        }
        state.averageClickInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
      }
      
      const quadrant = getQuadrant(e.clientX, e.clientY);
      state.movementAreas.set(quadrant, (state.movementAreas.get(quadrant) || 0) + 1);
      
      updatePhase();
      updateBackgroundIntensity();
      updateClickCounter();
      generateClickResponse(e.clientX, e.clientY);
    }

    function handleMouseMove(e) {
      if (!isActive) return;
      
      const distance = Math.sqrt(
        Math.pow(e.clientX - lastMouseX, 2) + 
        Math.pow(e.clientY - lastMouseY, 2)
      );
      
      if (distance > 10) {
        state.movements++;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        state.lastInteractionTime = Date.now();
        resetIdleTimer();
      }
    }

    function handleMouseEnter(e) {
      state.hovers++;
      const hoverStart = Date.now();
      
      const trackHover = () => {
        if (!isActive) return;
        const duration = Date.now() - hoverStart;
        state.hoverPattern.push(duration);
      };
      
      canvas.addEventListener('mouseleave', trackHover, { once: true });
    }

    function handleMouseLeave(e) {
      // Tracked in enter handler
    }

    function updatePhase() {
      const clicks = state.clicks;
      
      if (state.phase === 'initial' && clicks >= 4) {
        state.phase = 'trained';
        state.feedbackIntensity = 1.4;
      }
      
      if (state.phase === 'trained' && clicks >= 14 && !state.ruptureTriggered) {
        state.phase = 'rupture';
        state.ruptureTriggered = true;
        triggerRupture();
      }
      
      if (state.phase === 'rupture' && clicks >= 20) {
        state.phase = 'diminishing';
        state.feedbackIntensity = 0.6;
        state.responseDelay = 500;
      }
      
      if (state.phase === 'diminishing' && clicks >= 29) {
        state.phase = 'plateau';
        state.feedbackIntensity = 0.3;
        state.responseDelay = 1000;
      }
    }

    function triggerRupture() {
      state.responseDelay = 1400;
      state.feedbackIntensity = 0.35;
      
      setTimeout(() => {
        maybeShowText(14, window.innerWidth * 0.5, window.innerHeight * 0.5);
      }, 150);
      
      setTimeout(() => {
        state.responseDelay = 650;
        state.feedbackIntensity = 0.55;
      }, 10000);
    }

    function generateClickResponse(x, y) {
      const delay = state.responseDelay;
      const intensity = state.feedbackIntensity;
      
      if (state.phase === 'rupture' && state.clicks % 5 === 0) {
        return;
      }
      
      if (state.phase === 'plateau' && state.clicks % 3 === 0) {
        return;
      }
      
      setTimeout(() => {
        createInteractionPoint(x, y, intensity);
        
        if (state.phase === 'initial' || state.phase === 'trained') {
          createRipple(x, y, intensity);
        }
        
        if (state.phase === 'rupture' || state.phase === 'diminishing') {
          if (state.clicks % 3 === 0) {
            createGlitchBar();
          }
        }
        
        if (state.phase === 'rupture' && state.clicks % 4 === 0) {
          createDataCorruption(x, y);
        }
        
        if (state.phase === 'diminishing' && state.clicks % 3 === 0) {
          createDataCorruption(x, y);
          createGlitchBar();
        }
        
        if (state.phase === 'plateau' && state.clicks % 2 === 0) {
          createDataCorruption(x, y);
          createGlitchBar();
          createParticleBurst(x, y, intensity * 1.5);
        }
        
        if (state.phase !== 'initial') {
          createEchoNode(x, y);
          if (state.echoNodes.length > 1) {
            connectRecentNodes();
          }
        }
        
        if (state.phase === 'trained' && state.echoNodes.length >= 4 && state.clicks % 4 === 0) {
          predictNextAction();
        }
        
        const quadrantCount = state.movementAreas.get(getQuadrant(x, y)) || 0;
        if (quadrantCount > 0 && quadrantCount % 5 === 0) {
          createFieldDistortion(x, y);
        }
        
        if (state.phase === 'trained' && state.averageClickInterval > 0 && 
            state.averageClickInterval < 1500 && state.clicks % 3 === 0) {
          createParticleBurst(x, y, intensity);
        }
        
        maybeShowText(state.clicks, x, y);
      }, delay);
    }

    function createInteractionPoint(x, y, intensity) {
      const point = document.createElement('div');
      point.className = 'interaction-point';
      point.style.left = x + 'px';
      point.style.top = y + 'px';
      point.style.opacity = intensity;
      
      // Apply entropy class based on click count
      if (state.clicks >= 29) {
        point.classList.add('entropy-chaos');
      } else if (state.clicks >= 20) {
        point.classList.add('entropy-heavy');
      } else if (state.clicks >= 14) {
        point.classList.add('entropy-medium');
      } else if (state.clicks >= 8) {
        point.classList.add('entropy-light');
      }
      
      canvas.appendChild(point);
      
      setTimeout(() => {
        point.style.transition = 'opacity 1.5s ease, transform 1.5s ease';
        point.style.opacity = '0';
        point.style.transform = 'translate(-50%, -50%) scale(0.5)';
        setTimeout(() => point.remove(), 1500);
      }, 100);
    }

    function createRipple(x, y, intensity) {
      const ripple = document.createElement('div');
      ripple.className = 'ripple';
      ripple.style.left = x + 'px';
      ripple.style.top = y + 'px';
      ripple.style.width = '0px';
      ripple.style.height = '0px';
      ripple.style.opacity = intensity * 0.8;
      
      // Apply entropy class based on click count
      if (state.clicks >= 29) {
        ripple.classList.add('entropy-chaos');
      } else if (state.clicks >= 20) {
        ripple.classList.add('entropy-heavy');
      } else if (state.clicks >= 14) {
        ripple.classList.add('entropy-medium');
      } else if (state.clicks >= 8) {
        ripple.classList.add('entropy-light');
      }
      
      canvas.appendChild(ripple);
      
      setTimeout(() => {
        const size = 150 * intensity;
        ripple.style.transition = 'width 1.2s ease-out, height 1.2s ease-out, opacity 1.2s ease-out';
        ripple.style.width = size + 'px';
        ripple.style.height = size + 'px';
        ripple.style.opacity = '0';
        setTimeout(() => ripple.remove(), 1200);
      }, 50);
    }

    function maybeShowText(clickCount, x = null, y = null) {
      const sequence = textFragments.sequence;
      
      let textIndex = -1;
      
      if (clickCount === 1) textIndex = 0;
      else if (clickCount === 2) textIndex = 1;
      else if (clickCount === 4) textIndex = 2;
      else if (clickCount === 6) textIndex = 3;
      else if (clickCount === 8) textIndex = 4;
      else if (clickCount === 10) textIndex = 5;
      else if (clickCount === 12) textIndex = 6;
      else if (clickCount === 14) textIndex = 7;
      else if (clickCount === 16) textIndex = 8;
      else if (clickCount === 18) textIndex = 9;
      else if (clickCount === 20) textIndex = 10;
      else if (clickCount === 23) textIndex = 11;
      else if (clickCount === 26) textIndex = 12;
      else if (clickCount === 35) textIndex = 13;
      
      if (textIndex === -1) return;
      
      const existingFragments = canvas.querySelectorAll('.text-fragment');
      existingFragments.forEach(frag => {
        frag.style.transition = 'opacity 0.5s ease';
        frag.style.opacity = '0';
        setTimeout(() => frag.remove(), 500);
      });
      
      // Create thematic visual layer for this text
      const thematicLayer = createThematicLayer(textIndex);
      
      let text = sequence[textIndex];
      
      // Add opening ellipsis to RUINS on separate line before "Oh"
      if (textIndex === 14) {
        text = text.replace('Oh, you\'re still here?', '...\n\nOh, you\'re still here?');
      }
      
      const fragment = document.createElement('div');
      fragment.className = 'text-fragment';
      fragment.innerHTML = text;
      
      // FRACTURE and RUPTURE phases (clicks 14-17) - glitchy pink chaos
      if (clickCount >= 14 && clickCount <= 17) {
        fragment.classList.add('glitch-phase');
        fragment.style.color = '#ff0080';
        fragment.style.textShadow = '-8px 0 15px #ff0080, 8px 0 15px #ff00ff, 0 4px 15px #ff0080, 0 0 25px #ff0080';
        fragment.style.animation = 'rgb-split 0.2s infinite, entropy-glitch-chaos 0.4s infinite';
        fragment.style.filter = 'contrast(1.5) saturate(2)';
      } 
      // GRIEF - starts with glitch effect then stabilizes to white-blue (18)
      else if (clickCount === 18) {
        fragment.classList.add('glitch-phase');
        fragment.style.color = '#ff0080';
        fragment.style.textShadow = '-8px 0 15px #ff0080, 8px 0 15px #ff00ff, 0 4px 15px #ff0080, 0 0 25px #ff0080';
        fragment.style.animation = 'rgb-split 0.2s infinite, entropy-glitch-chaos 0.4s infinite';
        fragment.style.filter = 'contrast(1.5) saturate(2)';
        
        // Stabilize after 2 seconds
        setTimeout(() => {
          fragment.classList.remove('glitch-phase');
          fragment.style.transition = 'all 2s ease-out';
          fragment.style.color = '#e0f0ff';
          fragment.style.textShadow = '0 0 12px #e0f0ff, 0 0 25px #b0d5ff';
          fragment.style.animation = 'text-glitch 3s infinite';
          fragment.style.filter = 'saturate(1.2) brightness(1.15)';
        }, 2000);
      }
      // UNDERSTANDING onwards - same cyan-blue as grief with very slight glitch (20+)
      else if (clickCount >= 20) {
        fragment.style.color = '#e0f0ff';
        fragment.style.textShadow = '0 0 12px #e0f0ff, 0 0 25px #b0d5ff';
        fragment.style.animation = 'text-glitch 3s infinite';
        fragment.style.filter = 'saturate(1.2) brightness(1.15)';
      }
      // All other phases - calm green
      else {
        fragment.style.color = '#00ff41';
        fragment.style.textShadow = '0 0 8px #00ff41';
        fragment.style.animation = 'text-glitch 3s infinite';
      }
      
      // Always center text regardless of click position
      fragment.style.left = (window.innerWidth * 0.5) + 'px';
      fragment.style.top = (window.innerHeight * 0.5) + 'px';
      
      fragment.style.transform = 'translate(-50%, -50%)';
      
      canvas.appendChild(fragment);
      
      setTimeout(() => {
        fragment.style.transition = 'opacity 1.8s ease';
        fragment.style.opacity = '1';
      }, 200);
      
      // RUINS page (textIndex 13) never fades - it stays forever
      if (textIndex !== 13) {
        setTimeout(() => {
          fragment.style.transition = 'opacity 2.5s ease';
          fragment.style.opacity = '0';
          thematicLayer.style.transition = 'opacity 2.5s ease';
          thematicLayer.style.opacity = '0';
          setTimeout(() => {
            fragment.remove();
            thematicLayer.remove();
          }, 2500);
        }, 9000);
      }
    }

    function resetIdleTimer() {
      clearTimeout(idleTimer);
      idleTimer = setTimeout(handleIdle, 30000);
    }

    function handleIdle() {
      state.pauses++;
    }

    function getQuadrant(x, y) {
      const midX = window.innerWidth / 2;
      const midY = window.innerHeight / 2;
      
      if (x < midX && y < midY) return 'tl';
      if (x >= midX && y < midY) return 'tr';
      if (x < midX && y >= midY) return 'bl';
      return 'br';
    }

    function createEchoNode(x, y) {
      const node = document.createElement('div');
      node.className = 'echo-node';
      node.style.left = x + 'px';
      node.style.top = y + 'px';
      
      // Apply entropy class based on click count
      if (state.clicks >= 29) {
        node.classList.add('entropy-chaos');
      } else if (state.clicks >= 20) {
        node.classList.add('entropy-heavy');
      } else if (state.clicks >= 14) {
        node.classList.add('entropy-medium');
      } else if (state.clicks >= 8) {
        node.classList.add('entropy-light');
      }
      
      canvas.appendChild(node);
      
      state.echoNodes.push({ x, y, element: node, timestamp: Date.now() });
      
      setTimeout(() => {
        node.style.transition = 'transform 0.8s ease-out, opacity 0.8s ease-out';
        node.style.transform = 'translate(-50%, -50%) scale(1.5)';
        node.style.opacity = '0.2';
      }, 50);
      
      if (state.echoNodes.length > 12) {
        const oldest = state.echoNodes.shift();
        oldest.element.style.transition = 'opacity 1s ease';
        oldest.element.style.opacity = '0';
        setTimeout(() => oldest.element.remove(), 1000);
      }
    }

    function connectRecentNodes() {
      const recentCount = Math.min(state.echoNodes.length, 4);
      const recent = state.echoNodes.slice(-recentCount);
      
      for (let i = 0; i < recent.length - 1; i++) {
        const from = recent[i];
        const to = recent[i + 1];
        
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        
        const line = document.createElement('div');
        line.className = 'connection-line';
        line.style.left = from.x + 'px';
        line.style.top = from.y + 'px';
        line.style.width = '0px';
        line.style.transform = `rotate(${angle}deg)`;
        canvas.appendChild(line);
        
        setTimeout(() => {
          line.style.transition = 'width 0.6s ease-out, opacity 0.6s ease-out';
          line.style.width = distance + 'px';
        }, 50);
        
        setTimeout(() => {
          line.style.opacity = '0';
          setTimeout(() => line.remove(), 600);
        }, 2000);
      }
    }

    function predictNextAction() {
      if (state.echoNodes.length < 4) return;
      
      const recent = state.echoNodes.slice(-4);
      
      let totalDx = 0, totalDy = 0;
      for (let i = 1; i < recent.length; i++) {
        totalDx += recent[i].x - recent[i-1].x;
        totalDy += recent[i].y - recent[i-1].y;
      }
      const avgDx = totalDx / 3;
      const avgDy = totalDy / 3;
      
      const predictedX = recent[3].x + avgDx;
      const predictedY = recent[3].y + avgDy;
      
      if (predictedX < 50 || predictedX > window.innerWidth - 50 || 
          predictedY < 50 || predictedY > window.innerHeight - 50) return;
      
      const ghost = document.createElement('div');
      ghost.className = 'ghost-action';
      ghost.style.left = predictedX + 'px';
      ghost.style.top = predictedY + 'px';
      ghost.style.opacity = '0';
      canvas.appendChild(ghost);
      
      setTimeout(() => {
        ghost.style.transition = 'opacity 1.5s ease-in, transform 1.5s ease-in';
        ghost.style.opacity = '0.6';
        ghost.style.transform = 'translate(-50%, -50%) scale(1.2)';
      }, 100);
      
      setTimeout(() => {
        ghost.style.opacity = '0';
        setTimeout(() => ghost.remove(), 1500);
      }, 3000);
    }

    function createFieldDistortion(x, y) {
      const field = document.createElement('div');
      field.className = 'field-distortion';
      field.style.left = x + 'px';
      field.style.top = y + 'px';
      field.style.opacity = '0';
      canvas.appendChild(field);
      
      setTimeout(() => {
        field.style.transition = 'opacity 2s ease-in, transform 2s ease-in';
        field.style.opacity = '1';
        field.style.transform = 'translate(-50%, -50%) scale(1.5)';
      }, 50);
      
      setTimeout(() => {
        field.style.opacity = '0';
        setTimeout(() => field.remove(), 2000);
      }, 4000);
    }

    function createParticleBurst(x, y, intensity) {
      const particleCount = Math.floor(8 * intensity);
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = x + 'px';
        particle.style.top = y + 'px';
        canvas.appendChild(particle);
        
        const angle = (Math.PI * 2 * i) / particleCount;
        const velocity = 30 + Math.random() * 40;
        const dx = Math.cos(angle) * velocity;
        const dy = Math.sin(angle) * velocity;
        
        setTimeout(() => {
          particle.style.transition = 'transform 1.2s ease-out, opacity 1.2s ease-out';
          particle.style.transform = `translate(${dx}px, ${dy}px)`;
          particle.style.opacity = '0';
          setTimeout(() => particle.remove(), 1200);
        }, 50);
      }
    }

    function createGlitchBar() {
      const bar = document.createElement('div');
      bar.className = 'glitch-bar';
      bar.style.top = Math.random() * window.innerHeight + 'px';
      canvas.appendChild(bar);
      
      setTimeout(() => {
        bar.style.transition = 'opacity 0.3s ease';
        bar.style.opacity = '0';
        setTimeout(() => bar.remove(), 300);
      }, 100);
    }

    function createDataCorruption(x, y) {
      const chars = '01█▓�����������░╔╗║╚╝';
      const corruptionText = Array.from({ length: 15 }, () => chars[Math.floor(Math.random() * chars.length)]).join('');
      
      const corruption = document.createElement('div');
      corruption.className = 'data-corruption';
      corruption.textContent = corruptionText;
      corruption.style.left = (x + (Math.random() - 0.5) * 200) + 'px';
      corruption.style.top = (y + (Math.random() - 0.5) * 100) + 'px';
      canvas.appendChild(corruption);
      
      setTimeout(() => {
        corruption.style.transition = 'opacity 0.5s ease';
        corruption.style.opacity = '0';
        setTimeout(() => corruption.remove(), 500);
      }, 800);
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9bb12fa8001c9630',t:'MTc2NzkzMjg4OC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
